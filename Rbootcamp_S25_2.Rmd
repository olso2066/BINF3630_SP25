---
title: "R Notebook"
output: html_notebook
---

### R bootcamp Bioinformatics - Spring 2025

Objectives of this notebook: 

- use vectors and dataframes
- practice built-in functions and read documentation
- 

Functions in this notebook
- c()
- cbind()
- rbind()
- as.data.frame()
- subset()
- math functions (abs(), sqrt(), log(), log10(), exp())
- round(), floor(), ceiling(), signif()
- mean()
- replicate()
- sample()
- set.seed()

#### Vectors
A vector is a group of elements. You can think of it like a row or column in a spreadsheet. There is a defined order of the elements
```{r}
# From last time... we created the vector rn_list
rn_list = runif(n = 10, min = 0, max = 1)
rn_list
```

#### Making a vector with c()
```{r}
# Or, we can make a vector manually with the concatenate function c()
# concatenate 
manual_list <- c(1,2,3,4,5,6,7,8,9,10)
manual_list

another_list <- 1:10
another_list

### Compare manual_list to another_list with relational operators


```

#### Indexing vectors
```{r}
# We can grab elements from those vectors with indexing
# vector_name[index]
# NOTE: Indices in R begin with 1 (not 0 as in some languages)
one.element <- rn_list[1]
one.element

### You can get the length of a vector with the length() function
### Use length() and write lines of code to get the second to last element in the vector manual_list



```

#### Slicing vectors
```{r}
## Get multiple elements from a vector with slicing
## vectorName[Start : End]
# Note, the End is up to and including
many.elements<- rn_list[1:3]
many.elements
```

#### Combining vectors into a dataframe
```{r}
# We can combine vectors into a single dataframe
### Combine based on column
df.cbind <- cbind(manual_list,rn_list)
df.cbind <- as.data.frame(df.cbind)

### Combine based on row
df.rbind <- as.data.frame(rbind(manual_list,rn_list))


### Compare df.cbind and df.rbind - what do the cbind and rbind functions do?

```

# Indexing elements in a dataframe
```{r}
stats <- data.frame(player=c('A', 'B', 'C', 'D'),
                avepoints=c(50, 16, 35, 20),
                rebounds=c(4, 6, 1, 2))

stats
```

#### Indexing or accessing 
```{r}
# Access a column with its name
# dataframeName["columnName"]
rebound.stats <- stats["rebounds"]
rebound.stats

# Use logical operators to get players with more than 2 rebounds
# dataframeName[dataframName$columnName relational operator,]
# the comma at the end means all the rows will be displayed
# to get specific rows, follow the same conventions as for columns
high.rebounds <- stats[stats$rebounds>2,]
high.rebounds

# the subset() returns subsets of vectors, matrices or data frames which meet conditions
# subset( x = dataframe, subset = filter_logic, select=c(columnNames))
low.rebounds <- subset(x = stats, subset = rebounds <= 2, select = c(player,avepoints))
low.rebounds
?subset
```
#### math and other functions
```{r}
# Use each of the following functions abs(), sqrt(), log(), log10(), exp(), round(), floor(), ceiling(), signif(), mean()

# Look at the documentation for each one
# Write out the usage e.g., log(x, base = exp(1))
# Write an expression with each function

```

- replicate()
- sample()
- set.seed()

#### Repeat, replicate, and sample
```{r}
# repeat a function with replicate()
replicate(3, mean(rnorm(1000)))

```

```{r}
# sample with replacement
sample(c(1:10), 10, replace = T)

# sample without replacement
sample(c(1:10), 10, replace = F)

### Why would you use one over the other?

```

##### Pseudo-random numbers
'random' numbers generated by a computer are not random. Instead, they are calculated based on a "seed". That seed is based on the Year/Month/Day/Hour/Minute/Second/Millisecond

```{r}
# Run this chunk a few times
runif(5)
```

```{r}
# for testing and debugging code, you may want to set the seed
# Run this chunk a few times
set.seed(7)
runif(5)
```

